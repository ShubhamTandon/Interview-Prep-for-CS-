<!DOCTYPE HTML PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>


   <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 (Macintosh; U; PPC) [Netscape]">
   <meta name="Author" content="Nick Parlante">
   <meta name="Description" content="Stanford CS Education Library: this article introduces the basic concepts of binary trees, and then works through a series of practice problems with solution code in C/C++ and Java. Binary trees have an elegant recursive pointer structure, so they make a good introduction to recursive pointer algorithms.">
   <meta name="KeyWords" content="binary trees, binary tree problems, binary search trees, pointer, recursion, problems, solutions, code, introduction, C, C++, Java">
   <title>Binary Trees</title>
</head><body alink="#0000ff" bgcolor="#ffffff" text="#000000" vlink="#551a8b" link="#0000ff">

<center>
<h1>
Binary Trees</h1></center>

<center>by Nick Parlante</center>

<p>This article introduces the basic concepts of binary trees, and then
works through a series of practice problems with solution code in C/C++
and Java. Binary trees have an elegant recursive pointer structure, so
they are a good way to learn recursive pointer algorithms.
</p><h3>
Contents</h3>
<a href="#s1">Section 1</a>. Binary Tree Structure -- a quick introduction
to binary trees and the code that operates on them
<br><a href="#s2">Section 2</a>. Binary Tree Problems -- practice problems
in increasing order of difficulty
<br><a href="#csoln">Section 3</a>. C Solutions -- solution code to the
problems for C and C++ programmers
<br><a href="#java">Section 4</a>. Java versions -- how binary trees work
in Java, with solution code
<h3>
Stanford CS Education Library -- #110</h3>
This is article #110 in the Stanford CS Education Library. This and other
free CS materials are available at the library (<a href="http://cslibrary.stanford.edu/">http://cslibrary.stanford.edu/</a>).
That people seeking education should have the opportunity to find it. This
article may be used, reproduced, excerpted, or sold so long as this paragraph
is clearly reproduced. Copyright 2000-2001, Nick Parlante, nick.parlante@cs.stanford.edu.
<h3>
Related CSLibrary Articles</h3>

<ul>
<li>
Linked List Problems (<a href="http://cslibrary.stanford.edu/105/">http://cslibrary.stanford.edu/105/</a>)
-- a large collection of linked list problems using various pointer techniques
(while this binary tree article concentrates on recursion)</li>

<li>
Pointer and Memory (<a href="http://cslibrary.stanford.edu/102/">http://cslibrary.stanford.edu/102/</a>)
-- basic concepts of pointers and memory</li>

<li>
The Great Tree-List Problem (<a href="http://cslibrary.stanford.edu/109/">http://cslibrary.stanford.edu/109/</a>)
-- a great pointer recursion problem that uses both trees and lists</li>
</ul>

<h2>
<a name="s1"></a>Section 1 -- Introduction To Binary Trees</h2>
A binary tree is made of nodes, where each node contains a "left" pointer,
a "right" pointer, and a data element. The "root" pointer points to the
topmost node in the tree. The left and right pointers recursively point
to smaller "subtrees" on either side. A null pointer represents a binary
tree with no elements -- the empty tree. The formal recursive definition
is: a <b>binary tree </b>is either empty (represented by a null pointer),
or is made of a single node, where the left and right pointers (recursive
definition ahead) each point to a <b>binary tree</b>.
<br>&nbsp;
<p><img src="BinaryTrees_files/binarytree.gif" alt="a drawing of a little binary tree" border="0" width="420" height="264">
<br>&nbsp;
</p><p>A "binary search tree" (BST) or "ordered binary tree" is a type of binary
tree where the nodes are arranged in order: for each node, all elements
in its left subtree are less-or-equal to the node (&lt;=), and all the
elements in its right subtree are greater than the node (&gt;). The tree shown
above is a binary search tree -- the "root" node is a 5, and its left subtree
nodes (1, 3, 4) are &lt;= 5, and its right subtree nodes (6, 9) are &gt; 5.
Recursively, each of the subtrees must also obey the binary search tree
constraint: in the (1, 3, 4) subtree, the 3 is the root, the 1 &lt;= 3
and 4 &gt; 3. Watch out for the exact wording in the problems -- a "binary
search tree" is different from a "binary tree".
</p><p>The nodes at the bottom edge of the tree have empty subtrees and are
called "leaf" nodes (1, 4, 6) while the others are "internal" nodes (3,
5, 9).
</p><h3>
Binary Search Tree Niche</h3>
Basically, binary search trees are fast at insert and lookup. The next
section presents the code for these two algorithms. On average, a binary
search tree algorithm can locate a node in an N node tree in order lg(N)
time (log base 2). Therefore, binary search trees are good for "dictionary"
problems where the code inserts and looks up information indexed by some
key. The lg(N) behavior is the average case -- it's possible for a particular
tree to be much slower depending on its shape.
<h3>
Strategy</h3>
Some of the problems in this article use plain binary trees, and some use
binary search trees. In any case, the problems concentrate on the combination
of pointers and recursion. (See the articles linked above for pointer articles
that do not emphasize recursion.)
<p>For each problem, there are two things to understand...
</p><ul>
<li>
The node/pointer structure that makes up the tree and the code that manipulates
it</li>

<li>
The algorithm, typically recursive, that iterates over the tree</li>
</ul>
When thinking about a binary tree problem, it's often a good idea to draw
a few little trees to think about the various cases.
<h3>
Typical Binary Tree Code in C/C++</h3>
As an introduction, we'll look at the code for the two most basic binary
search tree operations -- lookup() and insert(). The code here works for
C or C++. Java programers can read the discussion here, and then look at
the Java versions in <a href="#java">Section 4</a>.
<p>In C or C++, the binary tree is built with a node type like this...
</p><p><tt>struct node {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int data;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct node* left;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct node* right;</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
Lookup()</h3>
Given a binary search tree and a "target" value, search the tree to see
if it contains the target. The basic pattern of the lookup() code occurs
in many recursive tree algorithms: deal with the base case where the tree
is empty, deal with the current node, and then use recursion to deal with
the subtrees. If the tree is a binary search tree, there is often some
sort of less-than test on the node to decide if the recursion should go
left or right.
<p><tt>/*</tt>
<br><tt>&nbsp;Given a binary tree, return true if a node</tt>
<br><tt>&nbsp;with the target data is found in the tree. Recurs</tt>
<br><tt>&nbsp;down the tree, chooses the left or right</tt>
<br><tt>&nbsp;branch by comparing the target to each node.</tt>
<br><tt>*/</tt>
<br><tt>static int lookup(struct node* node, int target) {</tt>
<br><tt>&nbsp; // 1. Base case == empty tree</tt>
<br><tt>&nbsp; // in that case, the target is not found so return false</tt>
<br><tt>&nbsp; if (node == NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(false);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // 2. see if found here</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (target == node-&gt;data) return(true);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3. otherwise recur down the correct
subtree</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (target &lt; node-&gt;data) return(lookup(node-&gt;left,
target));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return(lookup(node-&gt;right,
target));</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><p>The lookup() algorithm could be written as a while-loop that iterates
down the tree. Our version uses recursion to help prepare you for the problems
below that require recursion.
</p><h3>
Pointer Changing Code</h3>
There is a common problem with pointer intensive code: what if a function
needs to change one of the pointer parameters passed to it? For example,
the insert() function below may want to change the root pointer. In C and
C++, one solution uses pointers-to-pointers (aka "reference parameters").
That's a fine technique, but here we will use the simpler technique that
a function that wishes to change a pointer passed to it will <b>return</b>
the new value of the pointer to the caller. The caller is responsible for
using the new value. Suppose we have a change() function that may change
the the root, then a call to change() will look like this...
<p><tt>// suppose the variable "root" points to the tree</tt>
<br><tt>root = change(root);</tt>
</p><p>We take the value returned by change(), and use it as the new value
for root. This construct is a little awkward, but it avoids using reference
parameters which confuse some C and C++ programmers, and Java does not
have reference parameters at all. This allows us to focus on the recursion
instead of the pointer mechanics. (For lots of problems that use reference
parameters, see CSLibrary #105, Linked List Problems, <a href="http://cslibrary.stanford.edu/105/">http://cslibrary.stanford.edu/105/</a>).
</p><h3>
Insert()</h3>
Insert() -- given a binary search tree and a number, insert a new node
with the given number into the tree in the correct place. The insert()
code is similar to lookup(), but with the complication that it modifies
the tree structure. As described above, insert() returns the new tree pointer
to use to its caller. Calling insert() with the number 5 on this tree...
<p><tt>&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 1&nbsp;&nbsp; 10</tt>
</p><p>returns the tree...
</p><p><tt>&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 1&nbsp;&nbsp; 10</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5</tt>
</p><p>The solution shown here introduces a newNode() helper function that
builds a single node. The base-case/recursion structure is similar to the
structure in lookup() -- each call checks for the NULL case, looks at the
node at hand, and then recurs down the left or right subtree if needed.
</p><p><tt>/*</tt>
<br><tt>&nbsp;Helper function that allocates a new node</tt>
<br><tt>&nbsp;with the given data and NULL left and right</tt>
<br><tt>&nbsp;pointers.</tt>
<br><tt>*/</tt>
<br><tt>struct node* NewNode(int data) {</tt>
<br><tt>&nbsp; struct node* node = new(struct node);&nbsp;&nbsp;&nbsp;
// "new" is like "malloc"</tt>
<br><tt>&nbsp; node-&gt;data = data;</tt>
<br><tt>&nbsp; node-&gt;left = NULL;</tt>
<br><tt>&nbsp; node-&gt;right = NULL;</tt>
</p><p><tt>&nbsp; return(node);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><p><tt>/*</tt>
<br><tt>&nbsp;Give a binary search tree and a number, inserts a new node</tt>
<br><tt>&nbsp;with the given number in the correct place in the tree.</tt>
<br><tt>&nbsp;Returns the new root pointer which the caller should</tt>
<br><tt>&nbsp;then use (the standard trick to avoid using reference</tt>
<br><tt>&nbsp;parameters).</tt>
<br><tt>*/</tt>
<br><tt>struct node* insert(struct node* node, int data) {</tt>
<br><tt>&nbsp; // 1. If the tree is empty, return a new, single node</tt>
<br><tt>&nbsp; if (node == NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(newNode(data));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // 2. Otherwise, recur down the tree</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (data &lt;= node-&gt;data) node-&gt;left = insert(node-&gt;left,
data);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else node-&gt;right = insert(node-&gt;right, data);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; return(node); // return the (unchanged) node
pointer</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><p>The shape of a binary tree depends very much on the order that the nodes
are inserted. In particular, if the nodes are inserted in increasing order
(1, 2, 3, 4), the tree nodes just grow to the right leading to a linked
list shape where all the left pointers are NULL. A similar thing happens
if the nodes are inserted in decreasing order (4, 3, 2, 1). The linked
list shape defeats the lg(N) performance. We will not address that issue
here, instead focusing on pointers and recursion.
</p><h2 page-break-before="always">
<a name="s2"></a>Section 2 -- Binary Tree Problems</h2>
Here are 14 binary tree problems in increasing order of difficulty. Some
of the problems operate on binary search trees (aka "ordered binary trees")
while others work on plain binary trees with no special ordering. The next
section, <a href="#csoln">Section 3,</a> shows the solution code in C/C++.
<a href="#java">Section
4</a> gives the background and solution code in Java. The basic structure
and recursion of the solution code is the same in both languages -- the
differences are superficial.
<p>Reading about a data structure is a fine introduction, but at some point
the only way to learn is to actually try to solve some problems starting
with a blank sheet of paper. To get the most out of these problems, you
should at least attempt to solve them before looking at the solution. Even
if your solution is not quite right, you will be building up the right
skills. With any pointer-based code, it's a good idea to make memory drawings
of a a few simple cases to see how the algorithm should work.
</p><h3>
1. build123()</h3>
This is a very basic problem with a little pointer manipulation. (You can
skip this problem if you are already comfortable with pointers.) Write
code that builds the following little 1-2-3 binary search tree...
<p><tt>&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p>Write the code in three different ways...
</p><ul>
<li>
a: by calling newNode() three times, and using three pointer variables</li>

<li>
b: by calling newNode() three times, and using only one pointer variable</li>

<li>
c: by calling insert() three times passing it the root pointer to build
up the tree</li>
</ul>
(In Java, write a build123() method that operates on the receiver to change
it to be the 1-2-3 tree with the given coding constraints. See <a href="#java">Section
4</a>.)
<p>struct node* build123() {
<br>&nbsp;
</p><h3>
2. size()</h3>
This problem demonstrates simple binary tree traversal. Given a binary
tree, count the number of nodes in the tree.
<p>int size(struct node* node) {
<br>&nbsp;
</p><h3>
3. maxDepth()</h3>
Given a binary tree, compute its "maxDepth" -- the number of nodes along
the longest path from the root node down to the farthest leaf node. The
maxDepth of the empty tree is 0, the maxDepth of the tree on the first
page is 3.
<p>int maxDepth(struct node* node) {
<br>&nbsp;
</p><h3>
4. minValue()</h3>
Given a non-empty binary search tree (an ordered binary tree), return the
minimum data value found in that tree. Note that it is not necessary to
search the entire tree. A maxValue() function is structurally very similar
to this function. This can be solved with recursion or with a simple while
loop.
<p>int minValue(struct node* node) {
<br>&nbsp;
</p><h3>
5. printTree()</h3>
Given a binary search tree (aka an "ordered binary tree"), iterate over
the nodes to print them out in increasing order. So the tree...
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p>Produces the output "1 2 3 4 5". This is known as an "inorder" traversal
of the tree.
</p><p><b>Hint:</b> For each node, the strategy is: recur left, print the node
data, recur right.
</p><p>void printTree(struct node* node) {
<br>&nbsp;
</p><h3>
6. printPostorder()</h3>
Given a binary tree, print out the nodes of the tree according to a bottom-up
"postorder" traversal -- both subtrees of a node are printed out completely
before the node itself is printed, and each left subtree is printed before
the right subtree. So the tree...
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p>Produces the output "1 3 2 5 4". The description is complex, but the
code is simple. This is the sort of&nbsp; bottom-up traversal that would
be used, for example, to evaluate an expression tree where a node is an
operation like '+' and its subtrees are, recursively, the two subexpressions
for the '+'.
</p><p>void printPostorder(struct node* node) {
<br>&nbsp;
</p><h3>
7. hasPathSum()</h3>
We'll define a "root-to-leaf path" to be a sequence of nodes in a tree
starting with the root node and proceeding downward to a leaf (a node with
no children). We'll say that an empty tree contains no root-to-leaf paths.
So for example, the following tree has exactly four root-to-leaf paths:
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/ \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp; 8</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;
/ \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;
13&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</tt>
</p><p>Root-to-leaf paths:
<br><tt>&nbsp;&nbsp; path 1: 5 4 11 7</tt>
<br><tt>&nbsp;&nbsp; path 2: 5 4 11 2</tt>
<br><tt>&nbsp;&nbsp; path 3: 5 8 13</tt>
<br><tt>&nbsp;&nbsp; path 4: 5 8 4 1</tt>
</p><p>For this problem, we will be concerned with the sum of the values of
such a path -- for example, the sum of the values on the 5-4-11-7 path
is 5 + 4 + 11 + 7 = 27.
</p><p>Given a binary tree and a sum, return true if the tree has a root-to-leaf
path such that adding up all the values along the path equals the given
sum. Return false if no such path can be found. (Thanks to Owen Astrachan
for suggesting this problem.)
</p><p>int hasPathSum(struct node* node, int sum) {
<br>&nbsp;
</p><h3>
8. printPaths()</h3>
Given a binary tree, print out all of its root-to-leaf paths as defined
above. This problem is a little harder than it looks, since the "path so
far" needs to be communicated between the recursive calls. <b>Hint:</b>
In C, C++, and Java, probably the best solution is to create a recursive
helper function printPathsRecur(node, int path[], int pathLen), where the
path array communicates the sequence of nodes that led up to the current
call. Alternately, the problem may be solved bottom-up, with each node
returning its list of paths. This strategy works quite nicely in Lisp,
since it can exploit the built in list and mapping primitives. (Thanks
to Matthias Felleisen for suggesting this problem.)
<p>Given a binary tree, print out all of its root-to-leaf paths, one per
line.
</p><p>void printPaths(struct node* node) {
<br>&nbsp;
</p><h3>
9. mirror()</h3>
Change a tree so that the roles of the left and right pointers are swapped
at every node.
<p>&nbsp;So the tree...
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p>&nbsp;is changed to...
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 1</tt>
</p><p>The solution is short, but very recursive. As it happens, this can be
accomplished without changing the root node pointer, so the return-the-new-root
construct is not necessary. Alternately, if you do not want to change the
tree nodes, you may construct and return a new mirror tree based on the
original tree.
</p><p>void mirror(struct node* node) {
<br>&nbsp;
</p><h3>
10. doubleTree()</h3>
For each node in a binary search tree, create a new duplicate node, and
insert the duplicate as the left child of the original node. The resulting
tree should still be a binary search tree.
<p>&nbsp;So the tree...
<br><tt>&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p>&nbsp;is changed to...
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; /</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
<br><tt>&nbsp; /</tt>
<br><tt>&nbsp;1</tt>
</p><p>As with the previous problem, this can be accomplished without changing
the root node pointer.
</p><p>void doubleTree(struct node* node) {
<br>&nbsp;
</p><h3>
11. sameTree()</h3>
Given two binary trees, return true if they are structurally identical
-- they are made of nodes with the same values arranged in the same way.
(Thanks to Julie Zelenski for suggesting this problem.)
<p>int sameTree(struct node* a, struct node* b) {
<br>&nbsp;
</p><h3>
12. countTrees()</h3>
This is not a binary tree programming problem in the ordinary sense --
it's more of a math/combinatorics recursion problem that happens to use
binary trees. (Thanks to Jerry Cain for suggesting this problem.)
<p>Suppose you are building an N node binary search tree with the values
1..N. How many structurally different&nbsp; binary search trees are there
that store those values? Write a recursive function that, given the number
of distinct values, computes the number of structurally unique binary search
trees that store those values. For example, countTrees(4) should return
14, since there are 14&nbsp; structurally unique binary search trees that
store 1, 2, 3, and 4. The base case is easy, and the recursion is short
but dense. Your code should not construct any actual trees; it's just a
counting problem.
</p><p>int countTrees(int numKeys) {
<br>&nbsp;
<br>&nbsp;
</p><h3>
Binary Search Tree Checking (for problems 13 and 14)</h3>
This background is used by the next two problems: Given a plain binary
tree, examine the tree to determine if it meets the requirement to be a
binary search tree. To be a binary search tree, for every node, all of
the nodes in its left tree must be &lt;= the node, and all of the nodes
in its right subtree must be &gt; the node. Consider the following four examples...
<p><tt>a.&nbsp; 5&nbsp;&nbsp; -&gt; TRUE</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 2&nbsp;&nbsp; 7</tt>
<br>&nbsp;
</p><p><tt>b.&nbsp; 5&nbsp;&nbsp; -&gt; FALSE, because the 6 is not ok to the
left of the 5</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 6&nbsp;&nbsp; 7</tt>
<br>&nbsp;
</p><p><tt>c.&nbsp;&nbsp; 5&nbsp; -&gt; TRUE</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 2&nbsp;&nbsp; 7</tt>
<br><tt>&nbsp; /</tt>
<br><tt>&nbsp;1</tt>
</p><p><tt>d.&nbsp;&nbsp; 5&nbsp; -&gt; FALSE, the 6 is ok with the 2, but the
6 is not ok with the 5</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 2&nbsp;&nbsp; 7</tt>
<br><tt>&nbsp; / \</tt>
<br><tt>&nbsp;1&nbsp;&nbsp; 6</tt>
</p><p>For the first two cases, the right answer can be seen just by comparing
each node to the two nodes immediately below it. However, the fourth case
shows how checking the BST quality may depend on nodes which are several
layers apart -- the 5 and the 6 in that case.
<br>&nbsp;
</p><h3>
13 isBST() -- version 1</h3>
Suppose you have helper functions minValue() and maxValue() that return
the min or max int value from a non-empty tree (see problem 3 above). Write
an isBST() function that returns true if a tree is a binary search tree
and false otherwise. Use the helper functions, and don't forget to check
every node in the tree. It's ok if your solution is not very efficient.
(Thanks to Owen Astrachan for the idea of having this problem, and comparing
it to problem 14)
<p>Returns true if a binary tree is a binary search tree.
</p><p>int isBST(struct node* node) {
<br>&nbsp;
</p><h3>
14. isBST() -- version 2</h3>
Version 1 above runs slowly since it traverses over some parts of the tree
many times. A better solution looks at each node only once. The trick is
to write a utility helper function isBSTRecur(struct node* node, int min,
int max) that traverses down the tree keeping track of the narrowing min
and max allowed values as it goes, looking at each node only once. The
initial values for min and max should be INT_MIN and INT_MAX -- they narrow
from there.
<p>/*
<br>&nbsp;Returns true if the given tree is a binary search tree
<br>&nbsp;(efficient version).
<br>*/
<br>int isBST2(struct node* node) {
<br>&nbsp; return(isBSTRecur(node, INT_MIN, INT_MAX));
<br>}
</p><p>/*
<br>&nbsp;Returns true if the given tree is a BST and its
<br>&nbsp;values are &gt;= min and &lt;= max.
<br>*/
<br>int isBSTRecur(struct node* node, int min, int max) {
<br>&nbsp;
</p><h3>
15. Tree-List</h3>
The Tree-List problem is one of the greatest recursive pointer problems
ever devised, and it happens to use binary trees as well. CLibarary #109
<a href="http://cslibrary.stanford.edu/109/">http://cslibrary.stanford.edu/109/</a>&nbsp;
works through the Tree-List problem in detail and includes solution code
in C and Java. The problem requires an understanding of binary trees, linked
lists, recursion, and pointers. It's a great problem, but it's complex.
<br>&nbsp;
<br>&nbsp;
<h2>
<a name="csoln"></a>Section 3 -- C/C++ Solutions</h2>
Make an attempt to solve each problem before looking at the solution --
it's the best way to learn.
<h3>
1. Build123() Solution (C/C++)</h3>
<tt>// call newNode() three times</tt>
<br><tt>struct node* build123a() {</tt>
<br><tt>&nbsp; struct node* root = newNode(2);</tt>
<br><tt>&nbsp; struct node* lChild = newNode(1);</tt>
<br><tt>&nbsp; struct node* rChild = newNode(3);</tt>
<p><tt>&nbsp; root-&gt;left = lChild;</tt>
<br><tt>&nbsp; root-&gt;right= rChild;</tt>
</p><p><tt>&nbsp; return(root);</tt>
<br><tt>}</tt>
</p><p><tt>// call newNode() three times, and use only one local variable</tt>
<br><tt>struct node* build123b() {</tt>
<br><tt>&nbsp; struct node* root = newNode(2);</tt>
<br><tt>&nbsp; root-&gt;left = newNode(1);</tt>
<br><tt>&nbsp; root-&gt;right = newNode(3);</tt>
</p><p><tt>&nbsp; return(root);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><p><tt>/*</tt>
<br><tt>&nbsp;Build 123 by calling insert() three times.</tt>
<br><tt>&nbsp;Note that the '2' must be inserted first.</tt>
<br><tt>*/</tt>
<br><tt>struct node* build123c() {</tt>
<br><tt>&nbsp; struct node* root = NULL;</tt>
<br><tt>&nbsp; root = insert(root, 2);</tt>
<br><tt>&nbsp; root = insert(root, 1);</tt>
<br><tt>&nbsp; root = insert(root, 3);</tt>
<br><tt>&nbsp; return(root);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
2. size() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Compute the number of nodes in a tree.</tt>
<br><tt>*/</tt>
<br><tt>int size(struct node* node) {</tt>
<br><tt>&nbsp; if (node==NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(0);</tt>
<br><tt>&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(size(node-&gt;left) + 1 + size(node-&gt;right));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
<h3>
3. maxDepth() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Compute the "maxDepth" of a tree -- the number of nodes along</tt>
<br><tt>&nbsp;the longest path from the root node down to the farthest
leaf node.</tt>
<br><tt>*/</tt>
<br><tt>int maxDepth(struct node* node) {</tt>
<br><tt>&nbsp; if (node==NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(0);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // compute the depth of each subtree</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int lDepth = maxDepth(node-&gt;left);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rDepth = maxDepth(node-&gt;right);</tt>
<p><tt>&nbsp;&nbsp;&nbsp; // use the larger one</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (lDepth &gt; rDepth) return(lDepth+1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else return(rDepth+1);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
4. minValue() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Given a non-empty binary search tree,</tt>
<br><tt>&nbsp;return the minimum data value found in that tree.</tt>
<br><tt>&nbsp;Note that the entire tree does not need to be searched.</tt>
<br><tt>*/</tt>
<br><tt>int minValue(struct node* node) {</tt>
<br><tt>&nbsp; struct node* current = node;</tt>
<p><tt>&nbsp; // loop down to find the leftmost leaf</tt>
<br><tt>&nbsp; while (current-&gt;left != NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; current = current-&gt;left;</tt>
<br><tt>&nbsp; }</tt>
</p><p><tt>&nbsp; return(current-&gt;data);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
5. printTree() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Given a binary search tree, print out</tt>
<br><tt>&nbsp;its data elements in increasing</tt>
<br><tt>&nbsp;sorted order.</tt>
<br><tt>*/</tt>
<br><tt>void printTree(struct node* node) {</tt>
<br><tt>&nbsp; if (node == NULL) return;</tt>
<p><tt>&nbsp; printTree(node-&gt;left);</tt>
<br><tt>&nbsp; printf("%d ", node-&gt;data);</tt>
<br><tt>&nbsp; printTree(node-&gt;right);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
6. printPostorder() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Given a binary tree, print its</tt>
<br><tt>&nbsp;nodes according to the "bottom-up"</tt>
<br><tt>&nbsp;postorder traversal.</tt>
<br><tt>*/</tt>
<br><tt>void printPostorder(struct node* node) {</tt>
<br><tt>&nbsp; if (node == NULL) return;</tt>
<p><tt>&nbsp; // first recur on both subtrees</tt>
<br><tt>&nbsp; printTree(node-&gt;left);</tt>
<br><tt>&nbsp; printTree(node-&gt;right);</tt>
</p><p><tt>&nbsp; // then deal with the node</tt>
<br><tt>&nbsp; printf("%d ", node-&gt;data);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
7. hasPathSum() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Given a tree and a sum, return true if there is a path from
the root</tt>
<br><tt>&nbsp;down to a leaf, such that adding up all the values along
the path</tt>
<br><tt>&nbsp;equals the given sum.</tt>
<p><tt>&nbsp;Strategy: subtract the node value from the sum when recurring
down,</tt>
<br><tt>&nbsp;and check to see if the sum is 0 when you run out of tree.</tt>
<br><tt>*/</tt>
<br><tt>int hasPathSum(struct node* node, int sum) {</tt>
<br><tt>&nbsp; // return true if we run out of tree and sum==0</tt>
<br><tt>&nbsp; if (node == NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(sum == 0);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp; // otherwise check both subtrees</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int subSum = sum - node-&gt;data;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(hasPathSum(node-&gt;left, subSum) ||</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hasPathSum(node-&gt;right,
subSum));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
8. printPaths() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Given a binary tree, print out all of its root-to-leaf</tt>
<br><tt>&nbsp;paths, one per line. Uses a recursive helper to do the work.</tt>
<br><tt>*/</tt>
<br><tt>void printPaths(struct node* node) {</tt>
<br><tt>&nbsp; int path[1000];</tt>
<p><tt>&nbsp; printPathsRecur(node, path, 0);</tt>
<br><tt>}</tt>
</p><p><tt>/*</tt>
<br><tt>&nbsp;Recursive helper function -- given a node, and an array containing</tt>
<br><tt>&nbsp;the path from the root node up to but not including this
node,</tt>
<br><tt>&nbsp;print out all the root-leaf paths.</tt>
<br><tt>*/</tt>
<br><tt>void printPathsRecur(struct node* node, int path[], int pathLen)
{</tt>
<br><tt>&nbsp; if (node==NULL) return;</tt>
</p><p><tt>&nbsp; // append this node to the path array</tt>
<br><tt>&nbsp; path[pathLen] = node-&gt;data;</tt>
<br><tt>&nbsp; pathLen++;</tt>
</p><p><tt>&nbsp; // it's a leaf, so print the path that led to here</tt>
<br><tt>&nbsp; if (node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printArray(path, pathLen);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp; // otherwise try both subtrees</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printPathsRecur(node-&gt;left, path, pathLen);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printPathsRecur(node-&gt;right, path, pathLen);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
</p><p><tt>// Utility that prints out an array on a line.</tt>
<br><tt>void printArray(int ints[], int len) {</tt>
<br><tt>&nbsp; int i;</tt>
<br><tt>&nbsp; for (i=0; i&lt;len; i++) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf("%d ", ints[i]);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; printf("\n");</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
9. mirror() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Change a tree so that the roles of the</tt>
<br><tt>&nbsp;left and right pointers are swapped at every node.</tt>
<p><tt>&nbsp;So the tree...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p><tt>&nbsp;is changed to...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 1</tt>
<br><tt>*/</tt>
<br><tt>void mirror(struct node* node) {</tt>
<br><tt>&nbsp; if (node==NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct node* temp;</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; // do the subtrees</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mirror(node-&gt;left);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mirror(node-&gt;right);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; // swap the pointers in this node</tt>
<br><tt>&nbsp;&nbsp;&nbsp; temp = node-&gt;left;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; node-&gt;left = node-&gt;right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; node-&gt;right = temp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
10. doubleTree() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;For each node in a binary search tree,</tt>
<br><tt>&nbsp;create a new duplicate node, and insert</tt>
<br><tt>&nbsp;the duplicate as the left child of the original node.</tt>
<br><tt>&nbsp;The resulting tree should still be a binary search tree.</tt>
<p><tt>&nbsp;So the tree...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p><tt>&nbsp;Is changed to...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; /</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
<br><tt>&nbsp; /</tt>
<br><tt>&nbsp;1</tt>
</p><p><tt>*/</tt>
<br><tt>void doubleTree(struct node* node) {</tt>
<br><tt>&nbsp; struct node* oldLeft;</tt>
</p><p><tt>&nbsp; if (node==NULL) return;</tt>
</p><p><tt>&nbsp; // do the subtrees</tt>
<br><tt>&nbsp; doubleTree(node-&gt;left);</tt>
<br><tt>&nbsp; doubleTree(node-&gt;right);</tt>
</p><p><tt>&nbsp; // duplicate this node to its left</tt>
<br><tt>&nbsp; oldLeft = node-&gt;left;</tt>
<br><tt>&nbsp; node-&gt;left = newNode(node-&gt;data);</tt>
<br><tt>&nbsp; node-&gt;left-&gt;left = oldLeft;</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
11. sameTree() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Given two trees, return true if they are</tt>
<br><tt>&nbsp;structurally identical.</tt>
<br><tt>*/</tt>
<br><tt>int sameTree(struct node* a, struct node* b) {</tt>
<br><tt>&nbsp; // 1. both empty -&gt; true</tt>
<br><tt>&nbsp; if (a==NULL &amp;&amp; b==NULL) return(true);</tt>
<p><tt>&nbsp; // 2. both non-empty -&gt; compare them</tt>
<br><tt>&nbsp; else if (a!=NULL &amp;&amp; b!=NULL) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a-&gt;data == b-&gt;data &amp;&amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sameTree(a-&gt;left, b-&gt;left) &amp;&amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sameTree(a-&gt;right, b-&gt;right)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; );</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; // 3. one empty, one not -&gt; false</tt>
<br><tt>&nbsp; else return(false);</tt>
<br><tt>}</tt>
<br>&nbsp;
<br>&nbsp;
</p><h3>
12. countTrees() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;For the key values 1...numKeys, how many structurally unique</tt>
<br><tt>&nbsp;binary search trees are possible that store those keys.</tt>
<p><tt>&nbsp;Strategy: consider that each value could be the root.</tt>
<br><tt>&nbsp;Recursively find the size of the left and right subtrees.</tt>
<br><tt>*/</tt>
<br><tt>int countTrees(int numKeys) {</tt>
</p><p><tt>&nbsp; if (numKeys &lt;=1) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(1);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // there will be one value at the root, with
whatever remains</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // on the left and right each forming their
own subtrees.</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // Iterate through all the values that could
be the root...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int sum = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int left, right, root;</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; for (root=1; root&lt;=numKeys; root++) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = countTrees(root - 1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = countTrees(numKeys - root);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of possible trees with
this root == left*right</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += left*right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; return(sum);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
<br>&nbsp;
</p><h3>
13. isBST1() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Returns true if a binary tree is a binary search tree.</tt>
<br><tt>*/</tt>
<br><tt>int isBST(struct node* node) {</tt>
<br><tt>&nbsp; if (node==NULL) return(true);</tt>
<p><tt>&nbsp; // false if the max of the left is &gt; than us</tt>
</p><p><tt>&nbsp; // (bug -- an earlier version had min/max backwards here)</tt>
<br><tt>&nbsp; if (node-&gt;left!=NULL &amp;&amp; maxValue(node-&gt;left) &gt; node-&gt;data)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(false);</tt>
</p><p><tt>&nbsp; // false if the min of the right is &lt;= than us</tt>
<br><tt>&nbsp; if (node-&gt;right!=NULL &amp;&amp; minValue(node-&gt;right) &lt;=
node-&gt;data)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(false);</tt>
</p><p><tt>&nbsp; // false if, recursively, the left or right is not a BST</tt>
<br><tt>&nbsp; if (!isBST(node-&gt;left) || !isBST(node-&gt;right))</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(false);</tt>
</p><p><tt>&nbsp; // passing all that, it's a BST</tt>
<br><tt>&nbsp; return(true);</tt>
<br><tt>}</tt>
<br>&nbsp;
<br>&nbsp;
</p><h3>
14. isBST2() Solution (C/C++)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Returns true if the given tree is a binary search tree</tt>
<br><tt>&nbsp;(efficient version).</tt>
<br><tt>*/</tt>
<br><tt>int isBST2(struct node* node) {</tt>
<br><tt>&nbsp; return(isBSTUtil(node, INT_MIN, INT_MAX));</tt>
<br><tt>}</tt>
<p><tt>/*</tt>
<br><tt>&nbsp;Returns true if the given tree is a BST and its</tt>
<br><tt>&nbsp;values are &gt;= min and &lt;= max.</tt>
<br><tt>*/</tt>
<br><tt>int isBSTUtil(struct node* node, int min, int max) {</tt>
<br><tt>&nbsp; if (node==NULL) return(true);</tt>
</p><p><tt>&nbsp; // false if this node violates the min/max constraint</tt>
<br><tt>&nbsp; if (node-&gt;data&lt;min || node-&gt;data&gt;max) return(false);</tt>
</p><p><tt>&nbsp; // otherwise check the subtrees recursively,</tt>
<br><tt>&nbsp; // tightening the min or max constraint</tt>
<br><tt>&nbsp; return</tt>
<br><tt>&nbsp;&nbsp;&nbsp; isBSTUtil(node-&gt;left, min, node-&gt;data) &amp;&amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; isBSTUtil(node-&gt;right, node-&gt;data+1, max)</tt>
<br><tt>&nbsp; );</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
15. TreeList Solution (C/C++)</h3>
The solution code in C and Java to the great Tree-List recursion problem
is in CSLibrary #109&nbsp; <a href="http://cslibrary.stanford.edu/109/">http://cslibrary.stanford.edu/109/</a>
<h2>
<a name="java"></a>Section 4 -- Java Binary Trees and Solutions</h2>
In Java, the key points in the recursion are exactly the same as in C or
C++. In fact, I created the Java solutions by just copying the C solutions,
and then making the syntactic changes. The recursion is the same, however
the outer structure is slightly different.
<p>In Java, we will have a BinaryTree object that contains a single root
pointer. The root pointer points to an internal Node class that behaves
just like the node struct in the C/C++ version. The Node class is private
-- it is used only for internal storage inside the BinaryTree and is not
exposed to clients. With this OOP structure, almost every operation has
two methods: a one-line method on the BinaryTree that starts the computation,
and a recursive method that works on the Node objects. For the lookup()
operation, there is a BinaryTree.lookup() method that the client uses to
start a lookup operation. Internal to the BinaryTree class, there is a
private recursive lookup(Node) method that implements the recursion down
the Node structure. This second, private recursive method is basically
the same as the recursive C/C++ functions above -- it takes a Node argument
and uses recursion to iterate over the pointer structure.
</p><h3>
Java Binary Tree Structure</h3>
To get started, here are the basic definitions for the Java BinaryTree
class, and the lookup() and insert() methods as examples...
<p><tt>// BinaryTree.java</tt>
<br><tt>public class BinaryTree {</tt>
<br><tt>&nbsp; // Root node pointer. Will be null for an empty tree.</tt>
<br><tt>&nbsp; private Node root;</tt>
<br>&nbsp;
</p><p><tt>&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp; --Node--</tt>
<br><tt>&nbsp;&nbsp; The binary tree is built using this nested node class.</tt>
<br><tt>&nbsp;&nbsp; Each node stores one data element, and has left and
right</tt>
<br><tt>&nbsp;&nbsp; sub-tree pointer which may be null.</tt>
<br><tt>&nbsp;&nbsp; The node is a "dumb" nested class -- we just use it
for</tt>
<br><tt>&nbsp;&nbsp; storage; it does not have any methods.</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; private static class Node {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Node left;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Node right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int data;</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; Node(int newData) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = null;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = null;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = newData;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</p><p><tt>&nbsp; /**</tt>
<br><tt>&nbsp;&nbsp; Creates an empty binary tree -- a null root pointer.</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; public void BinaryTree() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; root = null;</tt>
<br><tt>&nbsp; }</tt>
<br>&nbsp;
</p><p><tt>&nbsp; /**</tt>
<br><tt>&nbsp;&nbsp; Returns true if the given target is in the binary
tree.</tt>
<br><tt>&nbsp;&nbsp; Uses a recursive helper.</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; public boolean lookup(int data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(lookup(root, data));</tt>
<br><tt>&nbsp; }</tt>
<br>&nbsp;
</p><p><tt>&nbsp; /**</tt>
<br><tt>&nbsp;&nbsp; Recursive lookup&nbsp; -- given a node, recur</tt>
<br><tt>&nbsp;&nbsp; down searching for the given data.</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; private boolean lookup(Node node, int data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (node==null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(false);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; if (data==node.data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else if (data&lt;node.data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(lookup(node.left, data));</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(lookup(node.right, data));</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br>&nbsp;
</p><p><tt>&nbsp; /**</tt>
<br><tt>&nbsp;&nbsp; Inserts the given data into the binary tree.</tt>
<br><tt>&nbsp;&nbsp; Uses a recursive helper.</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; public void insert(int data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; root = insert(root, data);</tt>
<br><tt>&nbsp; }</tt>
<br>&nbsp;
</p><p><tt>&nbsp; /**</tt>
<br><tt>&nbsp;&nbsp; Recursive insert -- given a node pointer, recur down
and</tt>
<br><tt>&nbsp;&nbsp; insert the given data into the tree. Returns the new</tt>
<br><tt>&nbsp;&nbsp; node pointer (the standard way to communicate</tt>
<br><tt>&nbsp;&nbsp; a changed pointer back to the caller).</tt>
<br><tt>&nbsp; */</tt>
<br><tt>&nbsp; private Node insert(Node node, int data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (node==null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node = new Node(data);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data &lt;= node.data) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node.left = insert(node.left,
data);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node.right = insert(node.right,
data);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; return(node); // in any case, return the new
pointer to the caller</tt>
<br><tt>&nbsp; }</tt>
<br>&nbsp;
</p><h3>
OOP Style vs. Recursive Style</h3>
From the client point of view, the BinaryTree class demonstrates good OOP
style -- it encapsulates the binary tree state, and the client sends messages
like lookup() and insert() to operate on that state. Internally, the Node
class and the recursive methods
<b>do not </b>demonstrate OOP style. The
recursive methods like insert(Node) and lookup (Node, int) basically look
like recursive functions in any language. In particular, they do not operate
against a "receiver" in any special way. Instead, the recursive methods
operate on the arguments that are passed in which is the classical way
to write recursion. My sense is that the OOP style and the recursive style
do not be combined nicely for binary trees, so I have left them separate.
Merging the two styles would be especially awkward for the "empty" tree
(null) case, since you can't send a message to the null pointer. It's possible
to get around that by having a special object to represent the null tree,
but that seems like a distraction to me. I prefer to keep the recursive
methods simple, and use different examples to teach OOP.
<h3>
Java Solutions</h3>
Here are the Java solutions to the 14 binary tree problems. Most of the
solutions use two methods:a one-line OOP method that starts the computation,
and a recursive method that does the real operation. Make an attempt to
solve each problem before looking at the solution -- it's the best way
to learn.
<h3>
1. Build123() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Build 123 using three pointer variables.</tt>
<br><tt>*/</tt>
<br><tt>public void build123a() {</tt>
<br><tt>&nbsp; root = new Node(2);</tt>
<br><tt>&nbsp; Node lChild = new Node(1);</tt>
<br><tt>&nbsp; Node rChild = new Node(3);</tt>
<p><tt>&nbsp; root.left = lChild;</tt>
<br><tt>&nbsp; root.right= rChild;</tt>
<br><tt>}</tt>
</p><p><tt>/**</tt>
<br><tt>&nbsp;Build 123 using only one pointer variable.</tt>
<br><tt>*/</tt>
<br><tt>public void build123b() {</tt>
<br><tt>&nbsp; root = new Node(2);</tt>
<br><tt>&nbsp; root.left = new Node(1);</tt>
<br><tt>&nbsp; root.right = new Node(3);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><p><tt>/**</tt>
<br><tt>&nbsp;Build 123 by calling insert() three times.</tt>
<br><tt>&nbsp;Note that the '2' must be inserted first.</tt>
<br><tt>*/</tt>
<br><tt>public void build123c() {</tt>
<br><tt>&nbsp; root = null;</tt>
<br><tt>&nbsp; root = insert(root, 2);</tt>
<br><tt>&nbsp; root = insert(root, 1);</tt>
<br><tt>&nbsp; root = insert(root, 3);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
2. size() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Returns the number of nodes in the tree.</tt>
<br><tt>&nbsp;Uses a recursive helper that recurs</tt>
<br><tt>&nbsp;down the tree and counts the nodes.</tt>
<br><tt>*/</tt>
<br><tt>public int size() {</tt>
<br><tt>&nbsp; return(size(root));</tt>
<br><tt>}</tt>
<p><tt>private int size(Node node) {</tt>
<br><tt>&nbsp; if (node == null) return(0);</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(size(node.left) + 1 + size(node.right));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
3. maxDepth() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Returns the max root-to-leaf depth of the tree.</tt>
<br><tt>&nbsp;Uses a recursive helper that recurs down to find</tt>
<br><tt>&nbsp;the max depth.</tt>
<br><tt>*/</tt>
<br><tt>public int maxDepth() {</tt>
<br><tt>&nbsp; return(maxDepth(root));</tt>
<br><tt>}</tt>
<p><tt>private int maxDepth(Node node) {</tt>
<br><tt>&nbsp; if (node==null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(0);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int lDepth = maxDepth(node.left);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rDepth = maxDepth(node.right);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; // use the larger + 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(Math.max(lDepth, rDepth) + 1);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
4. minValue() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Returns the min value in a non-empty binary search tree.</tt>
<br><tt>&nbsp;Uses a helper method that iterates to the left to find</tt>
<br><tt>&nbsp;the min value.</tt>
<br><tt>*/</tt>
<br><tt>public int minValue() {</tt>
<br><tt>&nbsp;return( minValue(root) );</tt>
<br><tt>}</tt>
<br>&nbsp;
<p><tt>/**</tt>
<br><tt>&nbsp;Finds the min value in a non-empty binary search tree.</tt>
<br><tt>*/</tt>
<br><tt>private int minValue(Node node) {</tt>
<br><tt>&nbsp; Node current = node;</tt>
<br><tt>&nbsp; while (current.left != null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; current = current.left;</tt>
<br><tt>&nbsp; }</tt>
</p><p><tt>&nbsp; return(current.data);</tt>
<br><tt>}</tt>
</p><h3>
5. printTree() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Prints the node values in the "inorder" order.</tt>
<br><tt>&nbsp;Uses a recursive helper to do the traversal.</tt>
<br><tt>*/</tt>
<br><tt>public void printTree() {</tt>
<br><tt>&nbsp;printTree(root);</tt>
<br><tt>&nbsp;System.out.println();</tt>
<br><tt>}</tt>
<p><tt>private void printTree(Node node) {</tt>
<br><tt>&nbsp;if (node == null) return;</tt>
</p><p><tt>&nbsp;// left, node itself, right</tt>
<br><tt>&nbsp;printTree(node.left);</tt>
<br><tt>&nbsp;System.out.print(node.data + "&nbsp; ");</tt>
<br><tt>&nbsp;printTree(node.right);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
6. printPostorder() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Prints the node values in the "postorder" order.</tt>
<br><tt>&nbsp;Uses a recursive helper to do the traversal.</tt>
<br><tt>*/</tt>
<br><tt>public void printPostorder() {</tt>
<br><tt>&nbsp;printPostorder(root);</tt>
<br><tt>&nbsp;System.out.println();</tt>
<br><tt>}</tt>
<p><tt>public void printPostorder(Node node) {</tt>
<br><tt>&nbsp; if (node == null) return;</tt>
</p><p><tt>&nbsp; // first recur on both subtrees</tt>
<br><tt>&nbsp; printPostorder(node.left);</tt>
<br><tt>&nbsp; printPostorder(node.right);</tt>
</p><p><tt>&nbsp; // then deal with the node</tt>
<br><tt>&nbsp;System.out.print(node.data + "&nbsp; ");</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
7. hasPathSum() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Given a tree and a sum, returns true if there is a path from
the root</tt>
<br><tt>&nbsp;down to a leaf, such that adding up all the values along
the path</tt>
<br><tt>&nbsp;equals the given sum.</tt>
<p><tt>&nbsp;Strategy: subtract the node value from the sum when recurring
down,</tt>
<br><tt>&nbsp;and check to see if the sum is 0 when you run out of tree.</tt>
<br><tt>*/</tt>
<br><tt>public boolean hasPathSum(int sum) {</tt>
<br><tt>&nbsp;return( hasPathSum(root, sum) );</tt>
<br><tt>}</tt>
</p><p><tt>boolean hasPathSum(Node node, int sum) {</tt>
<br><tt>&nbsp; // return true if we run out of tree and sum==0</tt>
<br><tt>&nbsp; if (node == null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(sum == 0);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp; // otherwise check both subtrees</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int subSum = sum - node.data;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(hasPathSum(node.left, subSum) || hasPathSum(node.right,
subSum));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
8. printPaths() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Given a binary tree, prints out all of its root-to-leaf</tt>
<br><tt>&nbsp;paths, one per line. Uses a recursive helper to do the work.</tt>
<br><tt>*/</tt>
<br><tt>public void printPaths() {</tt>
<br><tt>&nbsp; int[] path = new int[1000];</tt>
<br><tt>&nbsp; printPaths(root, path, 0);</tt>
<br><tt>}</tt>
<p><tt>/**</tt>
<br><tt>&nbsp;Recursive printPaths helper -- given a node, and an array
containing</tt>
<br><tt>&nbsp;the path from the root node up to but not including this
node,</tt>
<br><tt>&nbsp;prints out all the root-leaf paths.</tt>
<br><tt>*/</tt>
<br><tt>private void printPaths(Node node, int[] path, int pathLen) {</tt>
<br><tt>&nbsp; if (node==null) return;</tt>
</p><p><tt>&nbsp; // append this node to the path array</tt>
<br><tt>&nbsp; path[pathLen] = node.data;</tt>
<br><tt>&nbsp; pathLen++;</tt>
</p><p><tt>&nbsp; // it's a leaf, so print the path that led to here</tt>
<br><tt>&nbsp; if (node.left==null &amp;&amp; node.right==null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printArray(path, pathLen);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp; // otherwise try both subtrees</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printPaths(node.left, path, pathLen);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printPaths(node.right, path, pathLen);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
</p><p><tt>/**</tt>
<br><tt>&nbsp;Utility that prints ints from an array on one line.</tt>
<br><tt>*/</tt>
<br><tt>private void printArray(int[] ints, int len) {</tt>
<br><tt>&nbsp; int i;</tt>
<br><tt>&nbsp; for (i=0; i&lt;len; i++) {</tt>
<br><tt>&nbsp;&nbsp; System.out.print(ints[i] + " ");</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; System.out.println();</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
9. mirror() Solution (Java)</h3>

<p><br><tt>/**</tt>
<br><tt>&nbsp;Changes the tree into its mirror image.</tt>
</p><p><tt>&nbsp;So the tree...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 5</tt>
<br><tt>&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p><tt>&nbsp;is changed to...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 1</tt>
</p><p><tt>&nbsp;Uses a recursive helper that recurs over the tree,</tt>
<br><tt>&nbsp;swapping the left/right pointers.</tt>
<br><tt>*/</tt>
<br><tt>public void mirror() {</tt>
<br><tt>&nbsp; mirror(root);</tt>
<br><tt>}</tt>
</p><p><tt>private void mirror(Node node) {</tt>
<br><tt>&nbsp; if (node != null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // do the sub-trees</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mirror(node.left);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mirror(node.right);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; // swap the left/right pointers</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Node temp = node.left;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; node.left = node.right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; node.right = temp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
10. doubleTree() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Changes the tree by inserting a duplicate node</tt>
<br><tt>&nbsp;on each nodes's .left.</tt>
<br>&nbsp;
<br>&nbsp;
<p><tt>&nbsp;So the tree...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp; 1&nbsp;&nbsp; 3</tt>
</p><p><tt>&nbsp;Is changed to...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; /</tt>
<br><tt>&nbsp;&nbsp; 1&nbsp;&nbsp; 3</tt>
<br><tt>&nbsp; /</tt>
<br><tt>&nbsp;1</tt>
</p><p><tt>&nbsp;Uses a recursive helper to recur over the tree</tt>
<br><tt>&nbsp;and insert the duplicates.</tt>
<br><tt>*/</tt>
<br><tt>public void doubleTree() {</tt>
<br><tt>&nbsp;doubleTree(root);</tt>
<br><tt>}</tt>
</p><p><tt>private void doubleTree(Node node) {</tt>
<br><tt>&nbsp; Node oldLeft;</tt>
</p><p><tt>&nbsp; if (node == null) return;</tt>
</p><p><tt>&nbsp; // do the subtrees</tt>
<br><tt>&nbsp; doubleTree(node.left);</tt>
<br><tt>&nbsp; doubleTree(node.right);</tt>
</p><p><tt>&nbsp; // duplicate this node to its left</tt>
<br><tt>&nbsp; oldLeft = node.left;</tt>
<br><tt>&nbsp; node.left = new Node(node.data);</tt>
<br><tt>&nbsp; node.left.left = oldLeft;</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
11. sameTree() Solution (Java)</h3>
<tt>/*</tt>
<br><tt>&nbsp;Compares the receiver to another tree to</tt>
<br><tt>&nbsp;see if they are structurally identical.</tt>
<br><tt>*/</tt>
<br><tt>public boolean sameTree(BinaryTree other) {</tt>
<br><tt>&nbsp;return( sameTree(root, other.root) );</tt>
<br><tt>}</tt>
<p><tt>/**</tt>
<br><tt>&nbsp;Recursive helper -- recurs down two trees in parallel,</tt>
<br><tt>&nbsp;checking to see if they are identical.</tt>
<br><tt>*/</tt>
<br><tt>boolean sameTree(Node a, Node b) {</tt>
<br><tt>&nbsp; // 1. both empty -&gt; true</tt>
<br><tt>&nbsp; if (a==null &amp;&amp; b==null) return(true);</tt>
</p><p><tt>&nbsp; // 2. both non-empty -&gt; compare them</tt>
<br><tt>&nbsp; else if (a!=null &amp;&amp; b!=null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.data == b.data &amp;&amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sameTree(a.left, b.left) &amp;&amp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sameTree(a.right, b.right)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; );</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; // 3. one empty, one not -&gt; false</tt>
<br><tt>&nbsp; else return(false);</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
12. countTrees() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;For the key values 1...numKeys, how many structurally unique</tt>
<br><tt>&nbsp;binary search trees are possible that store those keys?</tt>
<p><tt>&nbsp;Strategy: consider that each value could be the root.</tt>
<br><tt>&nbsp;Recursively find the size of the left and right subtrees.</tt>
<br><tt>*/</tt>
<br><tt>public static int countTrees(int numKeys) {</tt>
<br><tt>&nbsp; if (numKeys &lt;=1) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(1);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // there will be one value at the root, with
whatever remains</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // on the left and right each forming their
own subtrees.</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // Iterate through all the values that could
be the root...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int sum = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int left, right, root;</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; for (root=1; root&lt;=numKeys; root++) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = countTrees(root-1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = countTrees(numKeys - root);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number of possible trees with
this root == left*right</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += left*right;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; return(sum);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
</p><h3>
13. isBST1() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Tests if a tree meets the conditions to be a</tt>
<br><tt>&nbsp;binary search tree (BST).</tt>
<br><tt>*/</tt>
<br><tt>public boolean isBST() {</tt>
<br><tt>&nbsp; return(isBST(root));</tt>
<br><tt>}</tt>
<p><tt>/**</tt>
<br><tt>&nbsp;Recursive helper -- checks if a tree is a BST</tt>
<br><tt>&nbsp;using minValue() and maxValue() (not efficient).</tt>
<br><tt>*/</tt>
<br><tt>private boolean isBST(Node node) {</tt>
<br><tt>&nbsp; if (node==null) return(true);</tt>
</p><p><tt>&nbsp; // do the subtrees contain values that do not</tt>
<br><tt>&nbsp; // agree with the node?</tt>
<br><tt>&nbsp; if (node.left!=null &amp;&amp; maxValue(node.left) &gt; node.data)
return(false);</tt>
<br><tt>&nbsp; if (node.right!=null &amp;&amp; minValue(node.right) &lt;=
node.data) return(false);</tt>
</p><p><tt>&nbsp; // check that the subtrees themselves are ok</tt>
<br><tt>&nbsp; return( isBST(node.left) &amp;&amp; isBST(node.right) );</tt>
<br><tt>}</tt>
<br>&nbsp;
<br>&nbsp;
</p><h3>
14. isBST2() Solution (Java)</h3>
<tt>/**</tt>
<br><tt>&nbsp;Tests if a tree meets the conditions to be a</tt>
<br><tt>&nbsp;binary search tree (BST). Uses the efficient</tt>
<br><tt>&nbsp;recursive helper.</tt>
<br><tt>*/</tt>
<br><tt>public boolean isBST2() {</tt>
<br><tt>&nbsp;return( isBST2(root, Integer.MIN_VALUE, Integer.MAX_VALUE)
);</tt>
<br><tt>}</tt>
<p><tt>/**</tt>
<br><tt>&nbsp; Efficient BST helper -- Given a node, and min and max values,</tt>
<br><tt>&nbsp; recurs down the tree to verify that it is a BST, and that
all</tt>
<br><tt>&nbsp; its nodes are within the min..max range. Works in O(n) time
--</tt>
<br><tt>&nbsp; visits each node only once.</tt>
<br><tt>*/</tt>
<br><tt>private boolean isBST2(Node node, int min, int max) {</tt>
<br><tt>&nbsp; if (node==null) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return(true);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp; // left should be in range&nbsp; min...node.data</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean leftOk = isBST2(node.left, min, node.data);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; // if the left is not ok, bail out</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (!leftOk) return(false);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; // right should be in range node.data+1..max</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean rightOk = isBST2(node.right, node.data+1,
max);</tt>
</p><p><tt>&nbsp;&nbsp;&nbsp; return(rightOk);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;

</p></body></html>